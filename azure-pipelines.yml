# Node.js
# Build a general Node.js project with npm.
# Add steps that analyze code, save build artifacts, and scan

trigger:
- master

pool:
  vmImage: ubuntu-latest

variables:
    enableCustomProcessTemplate: true
    customWorkItemType: Flaw
    customPTActiveStatus: Working
    customPTNewStatus: Introducing
    customPTResolvedStatus: Resolved
    customPTCloseStatus: Closed

steps:
- task: Bash@3
  displayName: Test OAuth Token
  enabled: false
  env:
    SYSTEM_ACCESSTOKEN: $(System.AccessToken)
  inputs:
    targetType: 'inline'
    script: |
      # Install jq for JSON parsing
      apt-get update && apt-get install -y jq

      # Dynamically retrieve the org and project name
      ORG_URL=$(echo $(System.CollectionUri))
      YOUR_PROJECT_NAME=$(echo $(System.TeamProject))

      # Extract only the organization name from ORG_URL (removes "https://dev.azure.com/")
      YOUR_ORG_NAME=$(echo $ORG_URL | sed 's|https://dev.azure.com/||')
      echo "Testing Azure DevOps OAuth Token..."
      curl -s -u :$SYSTEM_ACCESSTOKEN \
        "https://dev.azure.com/$YOUR_ORG_NAME/$YOUR_PROJECT_NAME/_apis/projects?api-version=6.0" | jq .

- task: Bash@3
  displayName: Auto-Packaing With Veracode CLI
  enabled: true
  inputs:
    targetType: "inline"
    script: |
      pwd
      export VERACODE_API_KEY_ID=$(VERACODE_API_ID)
      export VERACODE_API_KEY_SECRET=$(VERACODE_API_KEY)
      curl -fsS https://tools.veracode.com/veracode-cli/install | sh
      ./veracode package -s '$(Build.SourcesDirectory)' -o '$(build.artifactstagingdirectory)' -a trust

- task: Bash@3
  displayName: Container Scanning
  enabled: false
  inputs:
    targetType: "inline"
    script: |
      export VERACODE_API_KEY_ID=$(VERACODE_API_ID)
      export VERACODE_API_KEY_SECRET=$(VERACODE_API_KEY)
      # ./veracode scan --source alpine:latest --type image --format table || true
      ./veracode scan --source vulnerables/web-dvwa --type image --format table || true

- task: Veracode@3
  displayName: Upload & Scan
  enabled: false
  inputs:
    ConnectionDetailsSelection: 'Service Connection'
    AnalysisService: 'Veracode-Demo'
    veracodeAppProfile: 'nodegoat'
    version: 'nodegoat-$(build.buildNumber)'
    filepath: '$(build.artifactstagingdirectory)'
    # sandboxName: 'Azure DevOps'
    createSandBox: false
    importResults: true
    maximumWaitTime: '360'

- task: Veracode@3
  displayName: Create App Profile and Upload & Scan
  enabled: false
  inputs:
    ConnectionDetailsSelection: 'Service Connection'
    AnalysisService: 'Veracode-Demo'
    veracodeAppProfile: 'nodegoat-customfields'
    version: '$(build.buildNumber)'
    filepath: '$(build.artifactstagingdirectory)'
    optargs: '-customfield name="Language" value="NodeJS"'
    createProfile: true
    maximumWaitTime: '360'

- task: VeracodePipelineScan@0
  displayName: Pipeline Scan Before Mitigations
  enabled: true
  inputs:
    serviceConnection: 'Veracode-Demo'
    fileToScan: '$(build.artifactstagingdirectory)/veracode-auto-pack-s-js.zip'
    additionalFlags: '--fail_on_severity="Very High, High"'

- task: Bash@3
  displayName: Retrieve Mitigations with Debugging
  env:
    SYSTEM_ACCESSTOKEN: $(System.AccessToken)
  inputs:
    targetType: "inline"
    script: |
      echo "üîπ Starting debugging for Veracode mitigation retrieval..."

      # Ensure jq is installed
      if ! command -v jq &> /dev/null; then
        echo "üîπ jq not found, installing it locally..."
        mkdir -p "$HOME/bin"
        curl -Lo "$HOME/bin/jq" https://stedolan.github.io/jq/download/linux64/jq
        chmod +x "$HOME/bin/jq"
        export PATH="$HOME/bin:$PATH"
      fi
      jq --version

      # Retrieve organization & project name dynamically
      ORG_URL=$(echo $(System.CollectionUri) | sed 's/\/$//')  # Remove trailing slash if present
      PROJECT_NAME=$(echo $(System.TeamProject))
      ORG_NAME=$(echo $ORG_URL | sed 's|https://dev.azure.com/||')

      echo "üîπ Organization: $ORG_NAME"
      echo "üîπ Project: $PROJECT_NAME"
      echo "üîπ Service Connection: Veracode-Demo"

      # Fetch all service connections (updated API version and type filter)
      echo "üîπ Fetching all available service connections..."
      SERVICE_CONNECTION_RESPONSE=$(curl -s -u :$SYSTEM_ACCESSTOKEN \
          -H "Content-Type: application/json" \
          "$ORG_URL/$PROJECT_NAME/_apis/serviceendpoint/endpoints?api-version=7.1-preview.4&type=endpoint")

      echo "üîπ Raw Service Connection Response: $SERVICE_CONNECTION_RESPONSE"

      # Extract the Service Connection ID for "Veracode-Demo"
      SERVICE_CONNECTION_ID=$(echo $SERVICE_CONNECTION_RESPONSE | jq -r ".value[] | select(.name==\"Veracode-Demo\") | .id")

      echo "üîπ Retrieved Service Connection ID: $SERVICE_CONNECTION_ID"

      if [[ -z "$SERVICE_CONNECTION_ID" || "$SERVICE_CONNECTION_ID" == "null" ]]; then
          echo "‚ùå ERROR: Service Connection ID not found!"
          echo "üîπ Full Response: $SERVICE_CONNECTION_RESPONSE"
          echo "üîπ Possible Fixes:"
          echo "   - Ensure 'Veracode-Demo' exists in **this project** under Project Settings ‚Üí Service Connections"
          echo "   - Ensure the pipeline has permissions to access the service connection"
          echo "   - Try granting 'Grant access permission to all pipelines' in the service connection settings"
          exit 1
      fi

      # Fetch Service Connection Credentials
      echo "üîπ Fetching Service Connection Credentials..."
      AUTH_DETAILS=$(curl -s -u :$SYSTEM_ACCESSTOKEN \
          -H "Content-Type: application/json" \
          "$ORG_URL/_apis/serviceendpoint/endpoints/$SERVICE_CONNECTION_ID?api-version=7.1-preview.4")

      echo "üîπ Raw Auth Details Response: $AUTH_DETAILS"

      # Extract API Key ID and Secret
      VERACODE_API_KEY_ID=$(echo $AUTH_DETAILS | jq -r '.authorization.parameters.apitoken')
      VERACODE_API_KEY_SECRET=$(echo $AUTH_DETAILS | jq -r '.authorization.parameters.password')

      echo "üîπ API Key ID: ${VERACODE_API_KEY_ID:0:6}********"
      echo "üîπ API Key Secret Length: ${#VERACODE_API_KEY_SECRET}"

      if [[ -z "$VERACODE_API_KEY_ID" || "$VERACODE_API_KEY_SECRET" == "null" || "$VERACODE_API_KEY_ID" == "null" ]]; then
          echo "‚ùå ERROR: API credentials not retrieved!"
          exit 1
      fi

      # Export credentials as environment variables
      export VERACODE_API_KEY_ID
      export VERACODE_API_KEY_SECRET

      echo "‚úÖ Veracode credentials successfully retrieved!"

      # Run Mitigation Script
      echo "üîπ Cloning Veracode Pipeline Mitigation repository..."
      git clone https://github.com/tjarrettveracode/veracode-pipeline-mitigation
      pip install -r veracode-pipeline-mitigation/requirements.txt
      python veracode-pipeline-mitigation/vcpipemit.py -an nodegoat --results '$(Build.SourcesDirectory)/pipeline.json'
      mv baseline-*.json baseline.json





### DON'T EDIT
- task: VeracodePipelineScan@0
  displayName: Pipeline Scan After Mitigations
  enabled: true
  inputs:
    serviceConnection: 'Veracode-Demo'
    fileToScan: '$(build.artifactstagingdirectory)/veracode-auto-pack-s-js.zip'
    baselineFile: '$(Build.SourcesDirectory)/baseline.json'
    additionalFlags: '--fail_on_severity="Very High, High"'

- task: CmdLine@2
  displayName: SCA Agent-Based Scan
  enabled: false
  inputs:
    script: |
      export SCM_URI='https://nodegoat-ADO'
      export SRCCLR_API_TOKEN=$(SRCCLR_API_TOKEN)
      export scaDownloadUrl=https://download.srcclr.com/ci.sh
      export SCM_REF_TYPE=branch
      # make sure the branch name is set appropriately for the below scm_ref 
      export SCM_REF=master
      export SCM_REV=1.0
      curl -sSL $scaDownloadUrl | env bash -s scan --scm-uri $SCM_URI --scm-rev $SCM_REV --scm-ref $SCM_REF --scm-ref-type $SCM_REF_TYPE --update-advisor --allow-dirty

- task: Veracode Flaw Importer@3
  enabled: false
  inputs:
    ConnectionDetailsSelection: 'Service Connection'
    AnalysisService: 'Veracode-Demo'
    veracodeAppProfile: 'nodegoat'
    sandboxName: 'Azure DevOps'
    scanType: 'Static, SCA'
    importType: 'All Unmitigated Flaws Violating Policy'
    workItemType: 'Issue'
    area: '$(system.teamProject)'
    overwriteAreaPathInWorkItemsOnImport: true
    iterationPath: '$(system.teamProject)'
    overwriteIterationPath: true
    addCustomTag: 'external, internet facing'
    flawImportLimit: '1000'

